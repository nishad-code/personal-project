<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day 5 - Rose Petal Path üíç</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #ff6b9d 0%, #c06c84 50%, #6c5b7b 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }

        /* Floating items */
        .float-item {
            position: absolute;
            font-size: 25px;
            opacity: 0.12;
            animation: itemFloat 20s infinite;
            pointer-events: none;
        }

        @keyframes itemFloat {
            0% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 0.12;
            }
            90% {
                opacity: 0.12;
            }
            100% {
                transform: translateY(-100vh) rotate(360deg);
                opacity: 0;
            }
        }

        .container {
            text-align: center;
            padding: 20px;
            max-width: 700px;
            width: 100%;
            position: relative;
            z-index: 10;
        }

        .day-badge {
            display: inline-block;
            background: rgba(255, 215, 0, 0.3);
            border: 2px solid #ffd700;
            color: #fff;
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 14px;
            letter-spacing: 2px;
            margin-bottom: 20px;
            animation: glow 2s ease-in-out infinite;
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
        }

        h1 {
            color: #fff;
            font-size: 32px;
            margin-bottom: 15px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .subtitle {
            color: #ffd700;
            font-size: 16px;
            margin-bottom: 20px;
            font-style: italic;
        }

        .phase-indicator {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 15px;
            padding: 12px;
            margin-bottom: 15px;
            color: #ffd700;
            font-size: 15px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.7);
        }

        .phase-progress {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 8px;
        }

        .phase-item {
            width: 35px;
            height: 35px;
            border-radius: 8px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.3s ease;
        }

        .phase-item.collected {
            background: linear-gradient(135deg, #10b981, #059669);
            border-color: #10b981;
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.6);
        }

        .phase-item.locked {
            opacity: 0.3;
            filter: grayscale(1);
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
            gap: 10px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 215, 0, 0.4);
            border-radius: 15px;
            padding: 10px 15px;
            flex: 1;
        }

        .stat-label {
            color: #ffd700;
            font-size: 11px;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #fff;
            font-size: 22px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .timer-bar {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 15px;
            border: 2px solid rgba(255, 215, 0, 0.3);
        }

        .timer-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #ffd700, #ef4444);
            transition: width 0.1s linear;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }

        .game-area {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 20px;
            border: 3px solid rgba(255, 215, 0, 0.5);
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .level-display {
            color: #ffd700;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.7);
        }

        .maze-container {
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
            aspect-ratio: 1;
            background: linear-gradient(135deg, rgba(108, 91, 123, 0.3), rgba(192, 108, 132, 0.3));
            border-radius: 15px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        .maze-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 2px;
            width: 100%;
            height: 100%;
            padding: 5px;
        }

        .maze-cell {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
            position: relative;
            transition: all 0.2s ease;
        }

        .maze-cell.wall {
            background: linear-gradient(135deg, #4a4a4a, #2a2a2a);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .maze-cell.path {
            background: linear-gradient(135deg, rgba(255, 182, 193, 0.4), rgba(255, 105, 180, 0.3));
        }

        .maze-cell.rose {
            background: linear-gradient(135deg, rgba(255, 20, 147, 0.6), rgba(255, 105, 180, 0.4));
            animation: rosePulse 1.5s ease-in-out infinite;
        }

        @keyframes rosePulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 20, 147, 0.6); }
            50% { box-shadow: 0 0 20px rgba(255, 20, 147, 0.9); }
        }

        .maze-cell.heart {
            background: linear-gradient(135deg, rgba(255, 105, 180, 0.6), rgba(255, 182, 193, 0.4));
            animation: heartPulse 1.2s ease-in-out infinite;
        }

        @keyframes heartPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 105, 180, 0.6); }
            50% { box-shadow: 0 0 20px rgba(255, 105, 180, 0.9); }
        }

        .maze-cell.letter {
            background: linear-gradient(135deg, rgba(147, 51, 234, 0.6), rgba(168, 85, 247, 0.4));
            animation: letterPulse 1.3s ease-in-out infinite;
        }

        @keyframes letterPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(147, 51, 234, 0.6); }
            50% { box-shadow: 0 0 20px rgba(147, 51, 234, 0.9); }
        }

        .maze-cell.thorn {
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.6), rgba(178, 34, 34, 0.4));
            animation: thornPulse 1s ease-in-out infinite;
        }

        @keyframes thornPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .maze-cell.portal {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.6), rgba(75, 0, 130, 0.4));
            animation: portalSpin 2s linear infinite;
        }

        @keyframes portalSpin {
            0% { box-shadow: 0 0 15px rgba(138, 43, 226, 0.8); }
            50% { box-shadow: 0 0 25px rgba(138, 43, 226, 1); }
            100% { box-shadow: 0 0 15px rgba(138, 43, 226, 0.8); }
        }

        .maze-cell.visited {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 165, 0, 0.1));
        }

        .maze-cell.goal-locked {
            background: linear-gradient(135deg, rgba(100, 100, 100, 0.5), rgba(70, 70, 70, 0.3));
            opacity: 0.5;
        }

        .maze-cell.goal-unlocked {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.8), rgba(255, 165, 0, 0.6));
            animation: goalPulse 1s ease-in-out infinite;
        }

        @keyframes goalPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
            50% { box-shadow: 0 0 35px rgba(255, 215, 0, 1); }
        }

        .cell-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
        }

        .player {
            position: absolute;
            font-size: 28px;
            transition: all 0.15s ease;
            filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.7));
            z-index: 10;
            animation: playerBounce 0.5s ease-in-out infinite;
        }

        @keyframes playerBounce {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            max-width: 250px;
            margin: 15px auto;
        }

        .control-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: 2px solid rgba(255, 215, 0, 0.5);
            padding: 15px;
            border-radius: 12px;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
            user-select: none;
            font-weight: bold;
        }

        .control-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .control-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .control-btn.empty {
            background: none;
            border: none;
            box-shadow: none;
            cursor: default;
        }

        .start-btn {
            background: linear-gradient(135deg, #ffd700, #ff6b9d);
            color: white;
            border: none;
            padding: 15px 50px;
            border-radius: 30px;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.4);
            transition: all 0.3s ease;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 25px rgba(255, 215, 0, 0.6);
        }

        .start-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .hint {
            color: #ffd700;
            font-size: 13px;
            margin-top: 10px;
            line-height: 1.4;
        }

        .progress {
            margin-top: 15px;
            color: #ffd700;
            font-size: 14px;
        }

        .feedback-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 28px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.9);
            opacity: 0;
            pointer-events: none;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 35px;
            border-radius: 15px;
            max-width: 90%;
            text-align: center;
        }

        .feedback-msg.show {
            animation: feedbackShow 2s ease;
        }

        @keyframes feedbackShow {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -60%) scale(0.8); }
        }

        /* Win overlay */
        .win-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: fadeIn 0.5s ease;
        }

        .win-overlay.show {
            display: flex;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .win-content {
            text-align: center;
            padding: 40px;
            max-width: 400px;
            animation: slideUp 0.8s ease;
        }

        @keyframes slideUp {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .scratch-card-container {
            width: 250px;
            height: 250px;
            margin: 30px auto;
            border-radius: 15px;
            position: relative;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.6);
            animation: pieceGlow 2s ease-in-out infinite;
        }

        .scratch-card-container.hidden {
            display: none;
        }

        #scratchCanvas {
            position: absolute;
            top: 0;
            left: 0;
            border-radius: 15px;
            cursor: grab;
            z-index: 2;
        }

        #scratchCanvas:active {
            cursor: grabbing;
        }

        .scratch-instruction {
            color: #ffd700;
            font-size: 16px;
            margin-top: 20px;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .scratch-instruction.hidden {
            display: none;
        }

        .piece-reveal {
            width: 250px;
            height: 250px;
            margin: 30px auto;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.6);
            animation: pieceGlow 2s ease-in-out infinite;
            position: relative;
        }

        @keyframes pieceGlow {
            0%, 100% { box-shadow: 0 0 40px rgba(255, 215, 0, 0.6); }
            50% { box-shadow: 0 0 60px rgba(255, 215, 0, 0.9); }
        }

        .piece-reveal img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
        }

        .piece-reveal img.hidden {
            opacity: 0;
        }

        .piece-reveal img.fade-in {
            animation: fadeInImage 1s ease forwards;
        }

        @keyframes fadeInImage {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        .win-title {
            color: #ffd700;
            font-size: 36px;
            margin-bottom: 20px;
            animation: bounce 1s ease;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .win-message {
            color: #fff;
            font-size: 18px;
            line-height: 1.6;
            margin-bottom: 30px;
        }

        .see-you {
            color: #ffd700;
            font-size: 16px;
            font-style: italic;
            opacity: 0;
            animation: fadeInDelayed 1s ease 2s forwards;
        }

        @keyframes fadeInDelayed {
            to { opacity: 1; }
        }

        .particle {
            position: absolute;
            pointer-events: none;
            font-size: 20px;
            animation: particleFloat 3s ease-out forwards;
            z-index: 200;
        }

        @keyframes particleFloat {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--tx), var(--ty)) scale(0);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <!-- Floating items background -->
    <script>
        const floatItems = ['üíç', 'üåπ', 'üíï', 'üíù'];
        for (let i = 0; i < 12; i++) {
            const item = document.createElement('div');
            item.className = 'float-item';
            item.innerHTML = floatItems[Math.floor(Math.random() * floatItems.length)];
            item.style.left = Math.random() * 100 + '%';
            item.style.animationDelay = Math.random() * 20 + 's';
            item.style.animationDuration = (16 + Math.random() * 8) + 's';
            document.body.appendChild(item);
        }
    </script>

    <div class="container">
        <div class="day-badge">DAY 5 OF 7 - PROPOSE DAY</div>
        <h1>Rose Petal Path üíç</h1>
        <p class="subtitle">Collect all items in each phase to unlock the ring!</p>
        
        <!-- Phase Indicator -->
        <div class="phase-indicator" id="phaseIndicator">
            <div>Phase 1: Collect Roses üåπ</div>
            <div class="phase-progress" id="phaseProgress"></div>
        </div>

        <div class="stats">
            <div class="stat-box">
                <div class="stat-label">LEVEL</div>
                <div class="stat-value" id="levelDisplay">1/5</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">COLLECTED</div>
                <div class="stat-value" id="collectedDisplay">0/4</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">STEPS</div>
                <div class="stat-value" id="stepsDisplay">0</div>
            </div>
        </div>

        <div class="timer-bar">
            <div class="timer-fill" id="timerFill" style="width: 100%;"></div>
        </div>

        <div class="game-area">
            <div class="level-display" id="levelTitle">Level 1: First Meeting üíï</div>
            <div class="feedback-msg" id="feedbackMsg"></div>
            <div class="maze-container" id="mazeContainer">
                <div class="maze-grid" id="mazeGrid"></div>
                <div class="player" id="player">üíë</div>
            </div>
        </div>

        <div class="controls">
            <div class="control-btn empty"></div>
            <button class="control-btn" id="upBtn" onclick="movePlayer('up')">‚ñ≤</button>
            <div class="control-btn empty"></div>
            <button class="control-btn" id="leftBtn" onclick="movePlayer('left')">‚óÄ</button>
            <button class="control-btn" id="downBtn" onclick="movePlayer('down')">‚ñº</button>
            <button class="control-btn" id="rightBtn" onclick="movePlayer('right')">‚ñ∂</button>
        </div>

        <button class="start-btn" id="startBtn" onclick="startGame()">Start Journey üíç</button>
        <p class="hint">üí° Phase 1: Collect all üåπ roses (5)<br>Phase 2: Collect all üíï hearts (5)<br>Phase 3: Collect all üíå letters (5)<br>Then unlock the üíç ring! Avoid ‚öîÔ∏è thorns (-15s), use üåÄ portals!<br>‚ö†Ô∏è Each move costs 0.15s - plan your path!</p>
        <div class="progress" id="progress">Pieces unlocked: <span id="pieceCount">0</span> / 6</div>
    </div>

    <!-- Win Overlay -->
    <div class="win-overlay" id="winOverlay">
        <div class="win-content">
            <div class="win-title">Forever Yours! üíç‚ú®</div>
            
            <div class="scratch-card-container" id="scratchContainer">
                <img src="pieces/piece5.1.png" alt="Hidden Image" style="width: 100%; height: 100%; object-fit: cover; border-radius: 15px;">
                <canvas id="scratchCanvas" width="250" height="250"></canvas>
            </div>
            
            <p class="scratch-instruction" id="scratchInstruction">
                ‚ú® Scratch to reveal your surprise! ‚ú®
            </p>
            
            <div class="piece-reveal" id="pieceReveal" style="display: none;">
                <img src="pieces/piece5.1.png" alt="Puzzle Piece 5 - Cartoon" id="cartoonImage" class="fade-in">
                <img src="pieces/piece5.2.png" alt="Puzzle Piece 5 - Real" id="realImage" class="hidden">
            </div>
            
            <p class="win-message" id="winMessage" style="display: none;">
                "Through every obstacle,<br>
                I'll find my way to you.<br>
                You're my forever destination."
            </p>
            
            <p class="win-message" id="pieceUnlocked" style="display: none;">
                üß© <strong>Piece 5/6 unlocked!</strong>
            </p>
            
            <p class="see-you" id="seeYou" style="display: none;">Tomorrow, we celebrate our love... üíë</p>
        </div>
    </div>

    <script>
        const GRID_SIZE = 10;
        const TOTAL_LEVELS = 5;
        const TIME_PER_LEVEL = 45; // Reduced time for more challenge
        
        const LEVEL_THEMES = [
            { name: 'First Meeting', emoji: 'üíï' },
            { name: 'Growing Closer', emoji: 'üíñ' },
            { name: 'Deep Connection', emoji: 'üíó' },
            { name: 'The Question', emoji: 'üíç' },
            { name: 'Forever Together', emoji: 'üë∞‚Äç‚ôÄÔ∏èü§µ' }
        ];

        const PHASES = [
            { name: 'Collect Roses', emoji: 'üåπ', className: 'rose', count: 5 },
            { name: 'Collect Hearts', emoji: 'üíï', className: 'heart', count: 5 },
            { name: 'Collect Letters', emoji: 'üíå', className: 'letter', count: 5 }
        ];

        let gameActive = false;
        let currentLevel = 1;
        let currentPhase = 0;
        let playerPos = { x: 0, y: 0 };
        let goalPos = { x: 9, y: 9 };
        let phaseItemsCollected = 0;
        let totalSteps = 0;
        let levelTime = TIME_PER_LEVEL;
        let maze = [];
        let phaseItems = [];
        let thorns = [];
        let portals = [];
        let visited = new Set();
        let countdownTimer = null;
        let goalUnlocked = false;

        const mazeGrid = document.getElementById('mazeGrid');
        const player = document.getElementById('player');
        const levelDisplay = document.getElementById('levelDisplay');
        const levelTitle = document.getElementById('levelTitle');
        const collectedDisplay = document.getElementById('collectedDisplay');
        const stepsDisplay = document.getElementById('stepsDisplay');
        const timerFill = document.getElementById('timerFill');
        const startBtn = document.getElementById('startBtn');
        const feedbackMsg = document.getElementById('feedbackMsg');
        const phaseIndicator = document.getElementById('phaseIndicator');
        const phaseProgress = document.getElementById('phaseProgress');

        let scratchCanvas, scratchCtx, isScratching = false, scratchPercentage = 0;

        document.addEventListener('keydown', (e) => {
            if (!gameActive) return;
            e.preventDefault();
            
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') movePlayer('up');
            if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') movePlayer('down');
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') movePlayer('left');
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') movePlayer('right');
        });

        function startGame() {
            gameActive = true;
            currentLevel = 1;
            currentPhase = 0;
            phaseItemsCollected = 0;
            totalSteps = 0;
            goalUnlocked = false;
            
            updateDisplays();
            updatePhaseIndicator();
            
            startBtn.disabled = true;
            startBtn.textContent = 'Playing...';
            
            loadLevel(currentLevel);
        }

        function loadLevel(level) {
            levelTime = TIME_PER_LEVEL;
            visited.clear();
            currentPhase = 0;
            phaseItemsCollected = 0;
            goalUnlocked = false;
            
            levelDisplay.textContent = `${level}/${TOTAL_LEVELS}`;
            levelTitle.textContent = `Level ${level}: ${LEVEL_THEMES[level - 1].name} ${LEVEL_THEMES[level - 1].emoji}`;
            
            generateMaze(level);
            renderMaze();
            updatePhaseIndicator();
            updateDisplays();
            
            if (countdownTimer) clearInterval(countdownTimer);
            countdownTimer = setInterval(updateTimer, 100);
        }

        function generateMaze(level) {
            // Initialize empty maze
            maze = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
            
            playerPos = { x: 0, y: 0 };
            goalPos = { x: GRID_SIZE - 1, y: GRID_SIZE - 1 };
            
            // Add walls with controlled density
            const wallDensity = 0.15 + (level * 0.03); // Increased base density for more challenge
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if ((x === 0 && y === 0) || (x === GRID_SIZE - 1 && y === GRID_SIZE - 1)) continue;
                    if (Math.random() < wallDensity) {
                        maze[y][x] = 1;
                    }
                }
            }
            
            // CRITICAL: Ensure there's always a path from start to goal
            ensurePathExists();
            
            // Place phase items (roses, hearts, letters) - ensure they're all reachable
            phaseItems = [];
            const itemCount = PHASES[currentPhase].count;
            let placed = 0;
            let attempts = 0;
            
            while (placed < itemCount && attempts < 500) {
                const pos = getRandomEmptyCell();
                if (pos && isPositionReachable(pos)) {
                    phaseItems.push(pos);
                    placed++;
                }
                attempts++;
            }
            
            // If we still don't have enough items, clear some walls and place items
            while (placed < itemCount) {
                const pos = getRandomEmptyCell();
                if (pos) {
                    // Clear walls around this position to ensure reachability
                    clearWallsAroundPosition(pos);
                    if (isPositionReachable(pos)) {
                        phaseItems.push(pos);
                        placed++;
                    }
                }
                attempts++;
                if (attempts > 1000) break; // Safety break
            }
            
            // Place thorns (obstacles to avoid, but shouldn't block critical items)
            thorns = [];
            const thornCount = Math.max(2, Math.floor(level * 1.2));
            for (let i = 0; i < thornCount; i++) {
                let pos = getRandomEmptyCell();
                if (pos && isPositionReachable(pos)) {
                    // Make sure placing this thorn doesn't make items unreachable
                    const tempMaze = maze[pos.y][pos.x];
                    maze[pos.y][pos.x] = 1; // Temporarily block it
                    
                    // Check if all items are still reachable
                    let allItemsReachable = true;
                    for (const item of phaseItems) {
                        if (!isPositionReachable(item)) {
                            allItemsReachable = false;
                            break;
                        }
                    }
                    
                    if (allItemsReachable && hasPathToGoal()) {
                        // Safe to place thorn here (as an empty cell, not wall)
                        maze[pos.y][pos.x] = tempMaze; // Restore
                        thorns.push(pos);
                    } else {
                        // This would block critical paths, restore and skip
                        maze[pos.y][pos.x] = tempMaze;
                    }
                }
            }
            
            // Place portals (helpful for navigation, but rare)
            portals = [];
            if (level >= 3 && Math.random() < 0.6) { // Only 60% chance, and only on level 3+
                for (let i = 0; i < 1; i++) {
                    let pos1 = getRandomEmptyCell();
                    let pos2 = getRandomEmptyCell();
                    if (pos1 && pos2) {
                        portals.push({ from: pos1, to: pos2 });
                        portals.push({ from: pos2, to: pos1 });
                    }
                }
            }
        }

        function ensurePathExists() {
            // Use BFS to check if path exists
            let pathExists = hasPathToGoal();
            
            // If no path, remove walls until we have one
            let attempts = 0;
            while (!pathExists && attempts < 100) {
                // Find walls that are blocking
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        if (maze[y][x] === 1) {
                            // Try removing this wall
                            maze[y][x] = 0;
                            if (hasPathToGoal()) {
                                pathExists = true;
                                break;
                            }
                        }
                    }
                    if (pathExists) break;
                }
                attempts++;
            }
            
            // If still no path, create a simple corridor
            if (!pathExists) {
                for (let i = 0; i < GRID_SIZE; i++) {
                    maze[i][0] = 0; // Clear left column
                    maze[GRID_SIZE - 1][i] = 0; // Clear bottom row
                }
            }
        }

        function hasPathToGoal() {
            const queue = [{ x: 0, y: 0 }];
            const visited = new Set(['0,0']);
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                if (current.x === GRID_SIZE - 1 && current.y === GRID_SIZE - 1) {
                    return true;
                }
                
                const neighbors = [
                    { x: current.x + 1, y: current.y },
                    { x: current.x - 1, y: current.y },
                    { x: current.x, y: current.y + 1 },
                    { x: current.x, y: current.y - 1 }
                ];
                
                for (const next of neighbors) {
                    if (next.x >= 0 && next.x < GRID_SIZE && next.y >= 0 && next.y < GRID_SIZE) {
                        const key = `${next.x},${next.y}`;
                        if (!visited.has(key) && maze[next.y][next.x] === 0) {
                            visited.add(key);
                            queue.push(next);
                        }
                    }
                }
            }
            
            return false;
        }

        function isPositionReachable(pos) {
            // Check if position is reachable from player start (0,0)
            const queue = [{ x: 0, y: 0 }];
            const visited = new Set(['0,0']);
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                if (current.x === pos.x && current.y === pos.y) {
                    return true;
                }
                
                const neighbors = [
                    { x: current.x + 1, y: current.y },
                    { x: current.x - 1, y: current.y },
                    { x: current.x, y: current.y + 1 },
                    { x: current.x, y: current.y - 1 }
                ];
                
                for (const next of neighbors) {
                    if (next.x >= 0 && next.x < GRID_SIZE && next.y >= 0 && next.y < GRID_SIZE) {
                        const key = `${next.x},${next.y}`;
                        if (!visited.has(key) && maze[next.y][next.x] === 0) {
                            visited.add(key);
                            queue.push(next);
                        }
                    }
                }
            }
            
            return false;
        }

        function clearWallsAroundPosition(pos) {
            // Clear walls in a cross pattern around the position to ensure access
            const directions = [
                { x: 0, y: -1 }, { x: 0, y: 1 },
                { x: -1, y: 0 }, { x: 1, y: 0 }
            ];
            
            for (const dir of directions) {
                const newX = pos.x + dir.x;
                const newY = pos.y + dir.y;
                if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE) {
                    maze[newY][newX] = 0;
                }
            }
        }

        function isOnPathToGoal(pos) {
            // Check if position is reasonably on a path to goal
            const distToGoal = Math.abs(pos.x - goalPos.x) + Math.abs(pos.y - goalPos.y);
            const distFromStart = Math.abs(pos.x - playerPos.x) + Math.abs(pos.y - playerPos.y);
            return distFromStart > 2 && distToGoal > 2 && distToGoal < GRID_SIZE * 1.5;
        }

        function getRandomEmptyCell() {
            let attempts = 0;
            while (attempts < 100) {
                const x = Math.floor(Math.random() * GRID_SIZE);
                const y = Math.floor(Math.random() * GRID_SIZE);
                
                if (maze[y][x] === 0 && 
                    !(x === 0 && y === 0) && 
                    !(x === GRID_SIZE - 1 && y === GRID_SIZE - 1) &&
                    !phaseItems.find(r => r.x === x && r.y === y) &&
                    !thorns.find(t => t.x === x && t.y === y)) {
                    return { x, y };
                }
                attempts++;
            }
            return null;
        }

        function renderMaze() {
            mazeGrid.innerHTML = '';
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'maze-cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    
                    if (maze[y][x] === 1) {
                        cell.classList.add('wall');
                    }
                    
                    // Goal (ring)
                    if (x === goalPos.x && y === goalPos.y) {
                        if (goalUnlocked) {
                            cell.innerHTML = '<div class="cell-content">üíç</div>';
                            cell.classList.add('goal-unlocked');
                        } else {
                            cell.innerHTML = '<div class="cell-content">üîí</div>';
                            cell.classList.add('goal-locked');
                        }
                    }
                    
                    // Phase items (roses, hearts, letters)
                    if (phaseItems.find(r => r.x === x && r.y === y)) {
                        cell.innerHTML = `<div class="cell-content">${PHASES[currentPhase].emoji}</div>`;
                        cell.classList.add(PHASES[currentPhase].className);
                    }
                    
                    // Thorns
                    if (thorns.find(t => t.x === x && t.y === y)) {
                        cell.innerHTML = '<div class="cell-content">‚öîÔ∏è</div>';
                        cell.classList.add('thorn');
                    }
                    
                    // Portals
                    const portal = portals.find(p => p.from.x === x && p.from.y === y);
                    if (portal) {
                        cell.innerHTML = '<div class="cell-content">üåÄ</div>';
                        cell.classList.add('portal');
                    }
                    
                    mazeGrid.appendChild(cell);
                }
            }
            
            updatePlayerPosition();
        }

        function updatePhaseIndicator() {
            const phase = PHASES[currentPhase];
            phaseIndicator.querySelector('div:first-child').textContent = 
                `Phase ${currentPhase + 1}: ${phase.name} ${phase.emoji}`;
            
            phaseProgress.innerHTML = '';
            for (let i = 0; i < phase.count; i++) {
                const item = document.createElement('div');
                item.className = 'phase-item';
                if (i < phaseItemsCollected) {
                    item.classList.add('collected');
                    item.innerHTML = '‚úì';
                } else {
                    item.innerHTML = phase.emoji;
                }
                phaseProgress.appendChild(item);
            }
        }

        function movePlayer(direction) {
            if (!gameActive) return;
            
            let newX = playerPos.x;
            let newY = playerPos.y;
            
            if (direction === 'up') newY--;
            if (direction === 'down') newY++;
            if (direction === 'left') newX--;
            if (direction === 'right') newX++;
            
            if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) return;
            if (maze[newY][newX] === 1) return;
            
            playerPos.x = newX;
            playerPos.y = newY;
            totalSteps++;
            
            // Time penalty for each move to add pressure
            levelTime -= 0.15;
            
            const key = `${newX},${newY}`;
            if (!visited.has(key)) {
                visited.add(key);
                const cell = document.querySelector(`[data-x="${newX}"][data-y="${newY}"]`);
                if (cell && !cell.classList.contains('wall')) cell.classList.add('visited');
            }
            
            updatePlayerPosition();
            updateDisplays();
            checkCollisions();
        }

        function updatePlayerPosition() {
            const cellSize = mazeGrid.offsetWidth / GRID_SIZE;
            player.style.left = (playerPos.x * cellSize + cellSize / 2) + 'px';
            player.style.top = (playerPos.y * cellSize + cellSize / 2) + 'px';
        }

        function checkCollisions() {
            // Check phase item collection
            const itemIndex = phaseItems.findIndex(r => r.x === playerPos.x && r.y === playerPos.y);
            if (itemIndex !== -1) {
                phaseItems.splice(itemIndex, 1);
                phaseItemsCollected++;
                levelTime += 3; // Bonus time for collecting items
                updateDisplays();
                updatePhaseIndicator();
                
                const phase = PHASES[currentPhase];
                showFeedback(`${phase.emoji} Collected! +3s (${phaseItemsCollected}/${phase.count})`, false);
                createParticles(phase.emoji);
                
                const cell = document.querySelector(`[data-x="${playerPos.x}"][data-y="${playerPos.y}"]`);
                if (cell) {
                    cell.innerHTML = '';
                    cell.classList.remove(phase.className);
                }
                
                // Check if phase is complete
                if (phaseItemsCollected >= phase.count) {
                    currentPhase++;
                    phaseItemsCollected = 0;
                    
                    if (currentPhase >= PHASES.length) {
                        // All phases complete - unlock goal
                        goalUnlocked = true;
                        showFeedback('All items collected! üíç Ring Unlocked!', false);
                        levelTime += 5; // Reduced bonus time for challenge
                        renderMaze(); // Re-render to show unlocked goal
                    } else {
                        // Move to next phase
                        showFeedback(`Phase ${currentPhase} Complete! üéâ Next: ${PHASES[currentPhase].name}`, false);
                        levelTime += 5; // Reduced bonus time for completing phase
                        
                        // Generate new items for next phase - ensure all are reachable
                        phaseItems = [];
                        const itemCount = PHASES[currentPhase].count;
                        let placed = 0;
                        let attempts = 0;
                        
                        while (placed < itemCount && attempts < 500) {
                            const pos = getRandomEmptyCell();
                            if (pos && isPositionReachable(pos)) {
                                phaseItems.push(pos);
                                placed++;
                            }
                            attempts++;
                        }
                        
                        // If still not enough, clear walls and place
                        while (placed < itemCount && attempts < 1000) {
                            const pos = getRandomEmptyCell();
                            if (pos) {
                                clearWallsAroundPosition(pos);
                                if (isPositionReachable(pos)) {
                                    phaseItems.push(pos);
                                    placed++;
                                }
                            }
                            attempts++;
                        }
                        
                        updatePhaseIndicator();
                        renderMaze();
                    }
                }
            }
            
            // Check thorns
            const thornIndex = thorns.findIndex(t => t.x === playerPos.x && t.y === playerPos.y);
            if (thornIndex !== -1) {
                thorns.splice(thornIndex, 1);
                showFeedback('-15 seconds! ‚öîÔ∏è', true);
                levelTime -= 15; // Increased penalty
                createParticles('üíî');
                
                const cell = document.querySelector(`[data-x="${playerPos.x}"][data-y="${playerPos.y}"]`);
                if (cell) {
                    cell.innerHTML = '';
                    cell.classList.remove('thorn');
                }
            }
            
            // Check portals
            const portal = portals.find(p => p.from.x === playerPos.x && p.from.y === playerPos.y);
            if (portal) {
                playerPos.x = portal.to.x;
                playerPos.y = portal.to.y;
                updatePlayerPosition();
                showFeedback('Teleported! üåÄ', false);
                createParticles('‚ú®');
            }
            
            // Check goal
            if (goalUnlocked && playerPos.x === goalPos.x && playerPos.y === goalPos.y) {
                nextLevel();
            } else if (!goalUnlocked && playerPos.x === goalPos.x && playerPos.y === goalPos.y) {
                showFeedback('üîí Collect all items first!', true);
            }
        }

        function showFeedback(text, isNegative) {
            feedbackMsg.textContent = text;
            feedbackMsg.style.color = isNegative ? '#ef4444' : '#10b981';
            feedbackMsg.classList.add('show');
            setTimeout(() => feedbackMsg.classList.remove('show'), 2000);
        }

        function createParticles(emoji) {
            for (let i = 0; i < 8; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.innerHTML = emoji;
                particle.style.left = '50%';
                particle.style.top = '50%';
                
                const angle = (Math.PI * 2 * i) / 8;
                const distance = 60 + Math.random() * 60;
                particle.style.setProperty('--tx', Math.cos(angle) * distance + 'px');
                particle.style.setProperty('--ty', Math.sin(angle) * distance + 'px');
                
                document.body.appendChild(particle);
                setTimeout(() => particle.remove(), 3000);
            }
        }

        function nextLevel() {
            clearInterval(countdownTimer);
            
            if (currentLevel >= TOTAL_LEVELS) {
                winGame();
            } else {
                currentLevel++;
                showFeedback(`Level ${currentLevel - 1} Complete! üíï`, false);
                setTimeout(() => loadLevel(currentLevel), 2000);
            }
        }

        function updateDisplays() {
            const phase = PHASES[currentPhase] || PHASES[PHASES.length - 1];
            collectedDisplay.textContent = `${phaseItemsCollected}/${phase.count}`;
            stepsDisplay.textContent = totalSteps;
        }

        function updateTimer() {
            levelTime -= 0.1;
            const percentage = Math.max(0, (levelTime / TIME_PER_LEVEL) * 100);
            timerFill.style.width = percentage + '%';
            
            if (levelTime <= 0) {
                gameOver();
            }
        }

        function gameOver() {
            gameActive = false;
            clearInterval(countdownTimer);
            
            startBtn.disabled = false;
            startBtn.textContent = 'Try Again üíç';
            
            showFeedback('Time\'s Up! üíî', true);
        }

        function winGame() {
            gameActive = false;
            clearInterval(countdownTimer);
            
            localStorage.setItem('piece5', 'true');
            localStorage.setItem('day5_completed', 'true');
            
            setTimeout(() => {
                document.getElementById('winOverlay').classList.add('show');
                initScratchCard();
                createCelebration();
            }, 1000);
            
            updateProgress();
        }

        function initScratchCard() {
            scratchCanvas = document.getElementById('scratchCanvas');
            scratchCtx = scratchCanvas.getContext('2d');
            
            const gradient = scratchCtx.createLinearGradient(0, 0, 250, 250);
            gradient.addColorStop(0, '#ffd700');
            gradient.addColorStop(1, '#ff6b9d');
            scratchCtx.fillStyle = gradient;
            scratchCtx.fillRect(0, 0, 250, 250);
            
            scratchCtx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            for (let i = 0; i < 100; i++) {
                scratchCtx.fillRect(Math.random() * 250, Math.random() * 250, Math.random() * 3, Math.random() * 3);
            }
            
            scratchCtx.fillStyle = '#ffffff';
            scratchCtx.font = 'bold 24px Georgia';
            scratchCtx.textAlign = 'center';
            scratchCtx.fillText('Scratch Here!', 125, 115);
            scratchCtx.font = '20px Georgia';
            scratchCtx.fillText('üíç', 125, 145);
            
            scratchCanvas.addEventListener('mousedown', startScratch);
            scratchCanvas.addEventListener('mousemove', scratch);
            scratchCanvas.addEventListener('mouseup', stopScratch);
            scratchCanvas.addEventListener('touchstart', startScratch);
            scratchCanvas.addEventListener('touchmove', scratch);
            scratchCanvas.addEventListener('touchend', stopScratch);
        }

        function startScratch(e) {
            e.preventDefault();
            isScratching = true;
        }

        function scratch(e) {
            if (!isScratching) return;
            e.preventDefault();
            
            const rect = scratchCanvas.getBoundingClientRect();
            const x = (e.clientX || e.touches[0].clientX) - rect.left;
            const y = (e.clientY || e.touches[0].clientY) - rect.top;
            
            scratchCtx.globalCompositeOperation = 'destination-out';
            scratchCtx.beginPath();
            scratchCtx.arc(x, y, 20, 0, Math.PI * 2);
            scratchCtx.fill();
            
            checkScratchProgress();
        }

        function stopScratch() {
            isScratching = false;
        }

        function checkScratchProgress() {
            const imageData = scratchCtx.getImageData(0, 0, 250, 250);
            let transparent = 0;
            
            for (let i = 3; i < imageData.data.length; i += 4) {
                if (imageData.data[i] === 0) transparent++;
            }
            
            scratchPercentage = (transparent / (250 * 250)) * 100;
            
            if (scratchPercentage > 60) {
                revealImage();
            }
        }

        function revealImage() {
            document.getElementById('scratchContainer').classList.add('hidden');
            document.getElementById('scratchInstruction').classList.add('hidden');
            
            const pieceReveal = document.getElementById('pieceReveal');
            pieceReveal.style.display = 'block';
            
            document.getElementById('winMessage').style.display = 'block';
            document.getElementById('pieceUnlocked').style.display = 'block';
            document.getElementById('seeYou').style.display = 'block';
            
            setTimeout(() => {
                const cartoonImage = document.getElementById('cartoonImage');
                const realImage = document.getElementById('realImage');
                
                cartoonImage.classList.add('hidden');
                realImage.classList.remove('hidden');
                realImage.classList.add('fade-in');
            }, 3000);
        }

        function createCelebration() {
            const interval = setInterval(() => {
                for (let i = 0; i < 3; i++) {
                    const confetti = document.createElement('div');
                    confetti.className = 'particle';
                    confetti.innerHTML = ['üíç', 'üíï', 'üåπ', '‚ú®'][Math.floor(Math.random() * 4)];
                    confetti.style.left = Math.random() * window.innerWidth + 'px';
                    confetti.style.top = '0px';
                    confetti.style.setProperty('--tx', (Math.random() - 0.5) * 200 + 'px');
                    confetti.style.setProperty('--ty', window.innerHeight + 'px');
                    
                    document.body.appendChild(confetti);
                    setTimeout(() => confetti.remove(), 3000);
                }
            }, 150);
            
            setTimeout(() => clearInterval(interval), 5000);
        }

        function updateProgress() {
            let count = 0;
            for (let i = 1; i <= 6; i++) {
                if (localStorage.getItem(`piece${i}`) === 'true') {
                    count++;
                }
            }
            document.getElementById('pieceCount').textContent = count;
        }

        updateProgress();
    </script>
</body>
</html>